<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Castle.Facilities.QuartzIntegration</name>
    </assembly>
    <members>
        <member name="T:Castle.Facilities.QuartzIntegration.IJobScheduler">
            <summary>
            Light-weight job scheduler
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.IJobScheduler.GetJobKeys">
            <summary>
            Get all known jobs
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.IJobScheduler.RunJob(Quartz.JobKey)">
            <summary>
            Runs a job immediately
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.IJobScheduler.GetExecutingJobs">
            <summary>
            Get all currently executing jobs
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.IJobScheduler.PauseAll">
            <summary>
            Pauses all triggers
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.IJobScheduler.ResumeAll">
            <summary>
            Resumes all triggers
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.IJobScheduler.PauseJob(Quartz.JobKey)">
            <summary>
            Pauses a job's triggers
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.IJobScheduler.ResumeJob(Quartz.JobKey)">
            <summary>
            Resumes triggers of a paused job
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.IJobScheduler.DeleteJob(Quartz.JobKey)">
            <summary>
            Deletes a job
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.IJobScheduler.Interrupt(Quartz.JobKey)">
            <summary>
            Interrupts a running job
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.IJobScheduler.GetJobStatus(Quartz.JobKey)">
            <summary>
            Gets the job status, assuming it has only one trigger
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.#ctor(System.Collections.Generic.IDictionary{System.String,System.String},Quartz.Spi.IJobFactory,Castle.MicroKernel.IKernel)">
            <summary>
            Constructs a Scheduler that uses Castle Windsor
            </summary>
            <param name="props">Properties</param>
            <param name="jobFactory">JobFactory</param>
            <param name="kernel">Castle MicroKernel</param>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.IsJobGroupPaused(System.String)">
            <summary>
            returns true if the given JobGroup
                        is paused
            </summary>
            <param name="groupName"/>
            <returns/>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.IsTriggerGroupPaused(System.String)">
            <summary>
            returns true if the given TriggerGroup
                        is paused
            </summary>
            <param name="groupName"/>
            <returns/>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.GetMetaData">
            <summary>
            Get a <see cref="T:Quartz.SchedulerMetaData"/> object describing the settings
                        and capabilities of the scheduler instance.
            </summary>
            <remarks>
            Note that the data returned is an 'instantaneous' snap-shot, and that as
                        soon as it's returned, the meta data values may be different.
            </remarks>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.GetCurrentlyExecutingJobs">
            <summary>
            Return a list of <see cref="T:Quartz.IJobExecutionContext"/> objects that
                        represent all currently executing Jobs in this Scheduler instance.
            </summary>
            <remarks>
            <para>
            This method is not cluster aware.  That is, it will only return Jobs
                        currently executing in this Scheduler instance, not across the entire
                        cluster.
            </para>
            <para>
            Note that the list returned is an 'instantaneous' snap-shot, and that as
                        soon as it's returned, the true list of executing jobs may be different.
                        Also please read the doc associated with <see cref="T:Quartz.IJobExecutionContext"/>-
                        especially if you're using remoting.
            </para>
            </remarks>
            <seealso cref="T:Quartz.IJobExecutionContext"/>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.GetJobGroupNames">
            <summary>
            Get the names of all known <see cref="T:Quartz.IJobDetail"/> groups.
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.GetTriggerGroupNames">
            <summary>
            Get the names of all known <see cref="T:Quartz.ITrigger"/> groups.
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.GetPausedTriggerGroups">
            <summary>
            Get the names of all <see cref="T:Quartz.ITrigger"/> groups that are paused.
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.Start">
            <summary>
            Starts the <see cref="T:Quartz.IScheduler"/>'s threads that fire <see cref="T:Quartz.ITrigger"/>s.
                        When a scheduler is first created it is in "stand-by" mode, and will not
                        fire triggers.  The scheduler can also be put into stand-by mode by
                        calling the <see cref="M:Quartz.IScheduler.Standby"/> method.
            </summary>
            <remarks>
            The misfire/recovery process will be started, if it is the initial call
                        to this method on this scheduler instance.
            </remarks>
            <seealso cref="M:Quartz.IScheduler.StartDelayed(System.TimeSpan)"/><seealso cref="M:Quartz.IScheduler.Standby"/><seealso cref="M:Quartz.IScheduler.Shutdown(System.Boolean)"/>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.StartDelayed(System.TimeSpan)">
            <summary>
            Calls <see cref="M:Quartz.IScheduler.Start"/> after the indicated delay.
                        (This call does not block). This can be useful within applications that
                        have initializers that create the scheduler immediately, before the
                        resources needed by the executing jobs have been fully initialized.
            </summary>
            <seealso cref="M:Quartz.IScheduler.Start"/><seealso cref="M:Quartz.IScheduler.Standby"/><seealso cref="M:Quartz.IScheduler.Shutdown(System.Boolean)"/>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.Stop">
            <summary>
            Stops this instance.
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.Standby">
            <summary>
            Temporarily halts the <see cref="T:Quartz.IScheduler"/>'s firing of <see cref="T:Quartz.ITrigger"/>s.
            </summary>
            <remarks>
            <para>
            When <see cref="M:Quartz.IScheduler.Start"/> is called (to bring the scheduler out of 
                        stand-by mode), trigger misfire instructions will NOT be applied
                        during the execution of the <see cref="M:Quartz.IScheduler.Start"/> method - any misfires 
                        will be detected immediately afterward (by the <see cref="T:Quartz.Spi.IJobStore"/>'s 
                        normal process).
            </para>
            <para>
            The scheduler is not destroyed, and can be re-started at any time.
            </para>
            </remarks>
            <seealso cref="M:Quartz.IScheduler.Start"/><seealso cref="M:Quartz.IScheduler.PauseAll"/>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.Shutdown">
            <summary>
            Halts the <see cref="T:Quartz.IScheduler"/>'s firing of <see cref="T:Quartz.ITrigger"/>s,
                        and cleans up all resources associated with the Scheduler. Equivalent to
                        <see cref="M:Quartz.IScheduler.Shutdown(System.Boolean)"/>.
            </summary>
            <remarks>
            The scheduler cannot be re-started.
            </remarks>
            <seealso cref="M:Quartz.IScheduler.Shutdown(System.Boolean)"/>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.Shutdown(System.Boolean)">
            <summary>
            Halts the <see cref="T:Quartz.IScheduler"/>'s firing of <see cref="T:Quartz.ITrigger"/>s,
                        and cleans up all resources associated with the Scheduler. 
            </summary>
            <remarks>
            The scheduler cannot be re-started.
            </remarks>
            <param name="waitForJobsToComplete">if <see langword="true"/> the scheduler will not allow this method
                        to return until all currently executing jobs have completed.
                        </param><seealso cref="M:Quartz.IScheduler.Shutdown"/>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.ScheduleJob(Quartz.IJobDetail,Quartz.ITrigger)">
            <summary>
            Add the given <see cref="T:Quartz.IJobDetail"/> to the
                        Scheduler, and associate the given <see cref="T:Quartz.ITrigger"/> with
                        it.
            </summary>
            <remarks>
            If the given Trigger does not reference any <see cref="T:Quartz.IJob"/>, then it
                        will be set to reference the Job passed with it into this method.
            </remarks>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.ScheduleJob(Quartz.ITrigger)">
            <summary>
            Schedule the given <see cref="T:Quartz.ITrigger"/> with the
                        <see cref="T:Quartz.IJob"/> identified by the <see cref="T:Quartz.ITrigger"/>'s settings.
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.UnscheduleJob(Quartz.TriggerKey)">
            <summary>
            Remove the indicated <see cref="T:Quartz.ITrigger"/> from the scheduler.
            <para>
            If the related job does not have any other triggers, and the job is
                        not durable, then the job will also be deleted.
            </para>
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.UnscheduleJobs(System.Collections.Generic.IList{Quartz.TriggerKey})">
            <summary>
            Remove all of the indicated <see cref="T:Quartz.ITrigger"/>s from the scheduler.
            </summary>
            <remarks>
            <para>
            If the related job does not have any other triggers, and the job is
                        not durable, then the job will also be deleted.
            </para>
                        Note that while this bulk operation is likely more efficient than
                        invoking <see cref="M:Quartz.IScheduler.UnscheduleJob(Quartz.TriggerKey)"/> several
                        times, it may have the adverse affect of holding data locks for a
                        single long duration of time (rather than lots of small durations
                        of time).
            </remarks>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.RescheduleJob(Quartz.TriggerKey,Quartz.ITrigger)">
            <summary>
            Remove (delete) the <see cref="T:Quartz.ITrigger"/> with the
                        given key, and store the new given one - which must be associated
                        with the same job (the new trigger must have the job name &amp; group specified) 
                        - however, the new trigger need not have the same name as the old trigger.
            </summary>
            <param name="triggerKey">The <see cref="T:Quartz.ITrigger"/> to be replaced.</param><param name="newTrigger">The new <see cref="T:Quartz.ITrigger"/> to be stored.
                        </param>
            <returns>
            <see langword="null"/> if a <see cref="T:Quartz.ITrigger"/> with the given
                        name and group was not found and removed from the store (and the 
                        new trigger is therefore not stored),  otherwise
                        the first fire time of the newly scheduled trigger.
            </returns>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.AddJob(Quartz.IJobDetail,System.Boolean)">
            <summary>
            Add the given <see cref="T:Quartz.IJob"/> to the Scheduler - with no associated
                        <see cref="T:Quartz.ITrigger"/>. The <see cref="T:Quartz.IJob"/> will be 'dormant' until
                        it is scheduled with a <see cref="T:Quartz.ITrigger"/>, or <see cref="M:Quartz.IScheduler.TriggerJob(Quartz.JobKey)"/>
                        is called for it.
            </summary>
            <remarks>
            The <see cref="T:Quartz.IJob"/> must by definition be 'durable', if it is not,
                        SchedulerException will be thrown.
            </remarks>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.DeleteJob(Quartz.JobKey)">
            <summary>
            Delete the identified <see cref="T:Quartz.IJob"/> from the Scheduler - and any
                        associated <see cref="T:Quartz.ITrigger"/>s.
            </summary>
            <returns>
            true if the Job was found and deleted.
            </returns>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.DeleteJobs(System.Collections.Generic.IList{Quartz.JobKey})">
            <summary>
            Delete the identified jobs from the Scheduler - and any
                        associated <see cref="T:Quartz.ITrigger"/>s.
            </summary>
            <remarks>
            <para>
            Note that while this bulk operation is likely more efficient than
                        invoking <see cref="M:Quartz.IScheduler.DeleteJob(Quartz.JobKey)"/> several
                        times, it may have the adverse affect of holding data locks for a
                        single long duration of time (rather than lots of small durations
                        of time).
            </para>
            </remarks>
            <returns>
            true if all of the Jobs were found and deleted, false if
                        one or more were not deleted.
            </returns>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.TriggerJob(Quartz.JobKey)">
            <summary>
            Trigger the identified <see cref="T:Quartz.IJobDetail"/>
                        (Execute it now).
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.TriggerJob(Quartz.JobKey,Quartz.JobDataMap)">
            <summary>
            Trigger the identified <see cref="T:Quartz.IJobDetail"/> (Execute it now).
            </summary>
            <param name="data">the (possibly <see langword="null"/>) JobDataMap to be
                        associated with the trigger that fires the job immediately.
                        </param><param name="jobKey">The <see cref="T:Quartz.JobKey"/> of the <see cref="T:Quartz.IJob"/> to be executed.
                        </param>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.PauseJob(Quartz.JobKey)">
            <summary>
            Pause the <see cref="T:Quartz.IJobDetail"/> with the given
                        key - by pausing all of its current <see cref="T:Quartz.ITrigger"/>s.
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.PauseJobs(Quartz.Impl.Matchers.GroupMatcher{Quartz.JobKey})">
            <summary>
            Pause all of the <see cref="T:Quartz.IJobDetail"/>s in the
                        matching groups - by pausing all of their <see cref="T:Quartz.ITrigger"/>s.
            </summary>
            <remarks>
            <para>
            The Scheduler will "remember" that the groups are paused, and impose the
                        pause on any new jobs that are added to any of those groups until it is resumed.
            </para>
            <para>
            NOTE: There is a limitation that only exactly matched groups
                        can be remembered as paused.  For example, if there are pre-existing
                        job in groups "aaa" and "bbb" and a matcher is given to pause
                        groups that start with "a" then the group "aaa" will be remembered
                        as paused and any subsequently added jobs in group "aaa" will be paused,
                        however if a job is added to group "axx" it will not be paused,
                        as "axx" wasn't known at the time the "group starts with a" matcher 
                        was applied.  HOWEVER, if there are pre-existing groups "aaa" and
                        "bbb" and a matcher is given to pause the group "axx" (with a
                        group equals matcher) then no jobs will be paused, but it will be 
                        remembered that group "axx" is paused and later when a job is added 
                        in that group, it will become paused.
            </para>
            </remarks>
            <seealso cref="M:Quartz.IScheduler.ResumeJobs(Quartz.Impl.Matchers.GroupMatcher{Quartz.JobKey})"/>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.PauseTrigger(Quartz.TriggerKey)">
            <summary>
            Pause the <see cref="T:Quartz.ITrigger"/> with the given key.
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.PauseTriggers(Quartz.Impl.Matchers.GroupMatcher{Quartz.TriggerKey})">
            <summary>
            Pause all of the <see cref="T:Quartz.ITrigger"/>s in the groups matching.
            </summary>
            <remarks>
            <para>
            The Scheduler will "remember" all the groups paused, and impose the
                        pause on any new triggers that are added to any of those groups until it is resumed.
            </para>
            <para>
            NOTE: There is a limitation that only exactly matched groups
                        can be remembered as paused.  For example, if there are pre-existing
                        triggers in groups "aaa" and "bbb" and a matcher is given to pause
                        groups that start with "a" then the group "aaa" will be remembered as
                        paused and any subsequently added triggers in that group be paused,
                        however if a trigger is added to group "axx" it will not be paused,
                        as "axx" wasn't known at the time the "group starts with a" matcher 
                        was applied.  HOWEVER, if there are pre-existing groups "aaa" and
                        "bbb" and a matcher is given to pause the group "axx" (with a
                        group equals matcher) then no triggers will be paused, but it will be 
                        remembered that group "axx" is paused and later when a trigger is added
                        in that group, it will become paused.
            </para>
            </remarks>
            <seealso cref="M:Quartz.IScheduler.ResumeTriggers(Quartz.Impl.Matchers.GroupMatcher{Quartz.TriggerKey})"/>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.ResumeJob(Quartz.JobKey)">
            <summary>
            Resume (un-pause) the <see cref="T:Quartz.IJobDetail"/> with
                        the given key.
            </summary>
            <remarks>
            If any of the <see cref="T:Quartz.IJob"/>'s<see cref="T:Quartz.ITrigger"/> s missed one
                        or more fire-times, then the <see cref="T:Quartz.ITrigger"/>'s misfire
                        instruction will be applied.
            </remarks>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.ResumeJobs(Quartz.Impl.Matchers.GroupMatcher{Quartz.JobKey})">
            <summary>
            Resume (un-pause) all of the <see cref="T:Quartz.IJobDetail"/>s
                        in matching groups.
            </summary>
            <remarks>
            If any of the <see cref="T:Quartz.IJob"/> s had <see cref="T:Quartz.ITrigger"/> s that
                        missed one or more fire-times, then the <see cref="T:Quartz.ITrigger"/>'s
                        misfire instruction will be applied.
            </remarks>
            <seealso cref="M:Quartz.IScheduler.PauseJobs(Quartz.Impl.Matchers.GroupMatcher{Quartz.JobKey})"/>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.ResumeTrigger(Quartz.TriggerKey)">
            <summary>
            Resume (un-pause) the <see cref="T:Quartz.ITrigger"/> with the given
                        key.
            </summary>
            <remarks>
            If the <see cref="T:Quartz.ITrigger"/> missed one or more fire-times, then the
                        <see cref="T:Quartz.ITrigger"/>'s misfire instruction will be applied.
            </remarks>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.ResumeTriggers(Quartz.Impl.Matchers.GroupMatcher{Quartz.TriggerKey})">
            <summary>
            Resume (un-pause) all of the <see cref="T:Quartz.ITrigger"/>s in matching groups.
            </summary>
            <remarks>
            If any <see cref="T:Quartz.ITrigger"/> missed one or more fire-times, then the
                        <see cref="T:Quartz.ITrigger"/>'s misfire instruction will be applied.
            </remarks>
            <seealso cref="M:Quartz.IScheduler.PauseTriggers(Quartz.Impl.Matchers.GroupMatcher{Quartz.TriggerKey})"/>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.PauseAll">
            <summary>
            Pause all triggers - similar to calling <see cref="M:Quartz.IScheduler.PauseTriggers(Quartz.Impl.Matchers.GroupMatcher{Quartz.TriggerKey})"/>
                        on every group, however, after using this method <see cref="M:Quartz.IScheduler.ResumeAll"/> 
                        must be called to clear the scheduler's state of 'remembering' that all 
                        new triggers will be paused as they are added. 
            </summary>
            <remarks>
            When <see cref="M:Quartz.IScheduler.ResumeAll"/> is called (to un-pause), trigger misfire
                        instructions WILL be applied.
            </remarks>
            <seealso cref="M:Quartz.IScheduler.ResumeAll"/><seealso cref="M:Quartz.IScheduler.PauseTriggers(Quartz.Impl.Matchers.GroupMatcher{Quartz.TriggerKey})"/><seealso cref="M:Quartz.IScheduler.Standby"/>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.ResumeAll">
            <summary>
            Resume (un-pause) all triggers - similar to calling 
                        <see cref="M:Quartz.IScheduler.ResumeTriggers(Quartz.Impl.Matchers.GroupMatcher{Quartz.TriggerKey})"/> on every group.
            </summary>
            <remarks>
            If any <see cref="T:Quartz.ITrigger"/> missed one or more fire-times, then the
                        <see cref="T:Quartz.ITrigger"/>'s misfire instruction will be applied.
            </remarks>
            <seealso cref="M:Quartz.IScheduler.PauseAll"/>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.GetJobKeys(Quartz.Impl.Matchers.GroupMatcher{Quartz.JobKey})">
            <summary>
            Get the keys of all the <see cref="T:Quartz.IJobDetail"/>s in the matching groups.
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.GetTriggersOfJob(Quartz.JobKey)">
            <summary>
            Get all <see cref="T:Quartz.ITrigger"/> s that are associated with the
                        identified <see cref="T:Quartz.IJobDetail"/>.
            </summary>
            <remarks>
            The returned Trigger objects will be snap-shots of the actual stored
                        triggers.  If you wish to modify a trigger, you must re-store the
                        trigger afterward (e.g. see <see cref="M:Quartz.IScheduler.RescheduleJob(Quartz.TriggerKey,Quartz.ITrigger)"/>).
            </remarks>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.GetTriggerKeys(Quartz.Impl.Matchers.GroupMatcher{Quartz.TriggerKey})">
            <summary>
            Get the names of all the <see cref="T:Quartz.ITrigger"/>s in the given
                        groups.
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.GetJobDetail(Quartz.JobKey)">
            <summary>
            Get the <see cref="T:Quartz.IJobDetail"/> for the <see cref="T:Quartz.IJob"/>
                        instance with the given key .
            </summary>
            <remarks>
            The returned JobDetail object will be a snap-shot of the actual stored
                        JobDetail.  If you wish to modify the JobDetail, you must re-store the
                        JobDetail afterward (e.g. see <see cref="M:Quartz.IScheduler.AddJob(Quartz.IJobDetail,System.Boolean)"/>).
            </remarks>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.GetTrigger(Quartz.TriggerKey)">
            <summary>
            Get the <see cref="T:Quartz.ITrigger"/> instance with the given key.
            </summary>
            <remarks>
            The returned Trigger object will be a snap-shot of the actual stored
                        trigger.  If you wish to modify the trigger, you must re-store the
                        trigger afterward (e.g. see <see cref="M:Quartz.IScheduler.RescheduleJob(Quartz.TriggerKey,Quartz.ITrigger)"/>).
            </remarks>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.GetTriggerState(Quartz.TriggerKey)">
            <summary>
            Get the current state of the identified <see cref="T:Quartz.ITrigger"/>.
            </summary>
            <seealso cref="F:Quartz.TriggerState.Normal"/><seealso cref="F:Quartz.TriggerState.Paused"/><seealso cref="F:Quartz.TriggerState.Complete"/><seealso cref="F:Quartz.TriggerState.Blocked"/><seealso cref="F:Quartz.TriggerState.Error"/><seealso cref="F:Quartz.TriggerState.None"/>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.AddCalendar(System.String,Quartz.ICalendar,System.Boolean,System.Boolean)">
            <summary>
            Add (register) the given <see cref="T:Quartz.ICalendar"/> to the Scheduler.
            </summary>
            <param name="calName">Name of the calendar.</param><param name="calendar">The calendar.</param><param name="replace">if set to <c>true</c> [replace].</param><param name="updateTriggers">whether or not to update existing triggers that
                        referenced the already existing calendar so that they are 'correct'
                        based on the new trigger.</param>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.DeleteCalendar(System.String)">
            <summary>
            Delete the identified <see cref="T:Quartz.ICalendar"/> from the Scheduler.
            </summary>
            <remarks>
            If removal of the 
            <code>
            Calendar
            </code>
             would result in
                        <see cref="T:Quartz.ITrigger"/>s pointing to non-existent calendars, then a
                        <see cref="T:Quartz.SchedulerException"/> will be thrown.
            </remarks>
            <param name="calName">Name of the calendar.</param>
            <returns>
            true if the Calendar was found and deleted.
            </returns>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.GetCalendar(System.String)">
            <summary>
            Get the <see cref="T:Quartz.ICalendar"/> instance with the given name.
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.GetCalendarNames">
            <summary>
            Get the names of all registered <see cref="T:Quartz.ICalendar"/>.
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.Interrupt(Quartz.JobKey)">
            <summary>
            Request the interruption, within this Scheduler instance, of all 
                        currently executing instances of the identified <see cref="T:Quartz.IJob"/>, which 
                        must be an implementor of the <see cref="T:Quartz.IInterruptableJob"/> interface.
            </summary>
            <remarks>
            <para>
            If more than one instance of the identified job is currently executing,
                        the <see cref="M:Quartz.IInterruptableJob.Interrupt"/> method will be called on
                        each instance.  However, there is a limitation that in the case that  
                        <see cref="M:Quartz.IScheduler.Interrupt(Quartz.JobKey)"/> on one instances throws an exception, all 
                        remaining  instances (that have not yet been interrupted) will not have 
                        their <see cref="M:Quartz.IScheduler.Interrupt(Quartz.JobKey)"/> method called.
            </para>
            <para>
            If you wish to interrupt a specific instance of a job (when more than
                        one is executing) you can do so by calling 
                        <see cref="M:Quartz.IScheduler.GetCurrentlyExecutingJobs"/> to obtain a handle 
                        to the job instance, and then invoke <see cref="M:Quartz.IScheduler.Interrupt(Quartz.JobKey)"/> on it
                        yourself.
            </para>
            <para>
            This method is not cluster aware.  That is, it will only interrupt 
                        instances of the identified InterruptableJob currently executing in this 
                        Scheduler instance, not across the entire cluster.
            </para>
            </remarks>
            <returns>
            true is at least one instance of the identified job was found and interrupted.
            </returns>
            <seealso cref="T:Quartz.IInterruptableJob"/><seealso cref="M:Quartz.IScheduler.GetCurrentlyExecutingJobs"/>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.Interrupt(System.String)">
            <summary>
            Request the interruption, within this Scheduler instance, of the 
                        identified executing job instance, which 
                        must be an implementor of the <see cref="T:Quartz.IInterruptableJob"/> interface.
            </summary>
            <remarks>
            This method is not cluster aware.  That is, it will only interrupt 
                        instances of the identified InterruptableJob currently executing in this 
                        Scheduler instance, not across the entire cluster.
            </remarks>
            <seealso cref="M:Quartz.IInterruptableJob.Interrupt"/><seealso cref="M:Quartz.IScheduler.GetCurrentlyExecutingJobs"/><seealso cref="P:Quartz.IJobExecutionContext.FireInstanceId"/><seealso cref="M:Quartz.IScheduler.Interrupt(Quartz.JobKey)"/><param nane="fireInstanceId">the unique identifier of the job instance to  be interrupted (see <see cref="P:Quartz.IJobExecutionContext.FireInstanceId"/></param><param name="fireInstanceId"/>
            <returns>
            true if the identified job instance was found and interrupted.
            </returns>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.CheckExists(Quartz.JobKey)">
            <summary>
            Determine whether a <see cref="T:Quartz.IJob"/> with the given identifier already 
                        exists within the scheduler.
            </summary>
            <param name="jobKey">the identifier to check for</param>
            <returns>
            true if a Job exists with the given identifier
            </returns>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.CheckExists(Quartz.TriggerKey)">
            <summary>
            Determine whether a <see cref="T:Quartz.ITrigger"/> with the given identifier already 
                        exists within the scheduler.
            </summary>
            <param name="triggerKey">the identifier to check for</param>
            <returns>
            true if a Trigger exists with the given identifier
            </returns>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.Clear">
            <summary>
            Clears (deletes!) all scheduling data - all <see cref="T:Quartz.IJob"/>s, <see cref="T:Quartz.ITrigger"/>s
                        <see cref="T:Quartz.ICalendar"/>s.
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.WaitForJobsToCompleteAtShutdown">
            <summary>
            Wait for Jobs to finish when shutdown is triggered
            </summary>
        </member>
        <member name="P:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.SetGlobalJobListeners">
            <summary>
            Set by Castle via de configuration
            </summary>
            <remarks>This method is added for the backwards-compatibility with Quartz v1 and the QuartzFacility v1</remarks>
        </member>
        <member name="P:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.SetGlobalTriggerListeners">
            <summary>
            Set by Castle via de configuration
            </summary>
            <remarks>This method is added for the backwards-compatibility with Quartz v1 and the QuartzFacility v1</remarks>
        </member>
        <member name="P:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.JobListeners">
            <summary>
            Set by Castle via de configuration
            </summary>
            <remarks>This method is added for the backwards-compatibility with Quartz v1 and the QuartzFacility v1</remarks>
        </member>
        <member name="P:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.TriggerListeners">
            <summary>
            Set by Castle via de configuration
            </summary>
            <remarks>This method is added for the backwards-compatibility with Quartz v1 and the QuartzFacility v1</remarks>
        </member>
        <member name="P:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.SchedulerName">
            <summary>
            Returns the name of the <see cref="T:Quartz.IScheduler"/>.
            </summary>
        </member>
        <member name="P:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.SchedulerInstanceId">
            <summary>
            Returns the instance Id of the <see cref="T:Quartz.IScheduler"/>.
            </summary>
        </member>
        <member name="P:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.Context">
            <summary>
            Returns the <see cref="T:Quartz.SchedulerContext"/> of the <see cref="T:Quartz.IScheduler"/>.
            </summary>
        </member>
        <member name="P:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.InStandbyMode">
            <summary>
            Reports whether the <see cref="T:Quartz.IScheduler"/> is in stand-by mode.
            </summary>
            <seealso cref="M:Quartz.IScheduler.Standby"/><seealso cref="M:Quartz.IScheduler.Start"/>
        </member>
        <member name="P:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.IsShutdown">
            <summary>
            Reports whether the <see cref="T:Quartz.IScheduler"/> has been Shutdown.
            </summary>
        </member>
        <member name="P:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.JobFactory">
            <summary>
            Set the <see cref="P:Quartz.IScheduler.JobFactory"/> that will be responsible for producing 
                        instances of <see cref="T:Quartz.IJob"/> classes.
            </summary>
            <remarks>
            JobFactories may be of use to those wishing to have their application
                        produce <see cref="T:Quartz.IJob"/> instances via some special mechanism, such as to
                        give the opportunity for dependency injection.
            </remarks>
            <seealso cref="T:Quartz.Spi.IJobFactory"/>
        </member>
        <member name="P:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.ListenerManager">
            <summary>
            Get a reference to the scheduler's <see cref="T:Quartz.IListenerManager"/>,
                        through which listeners may be registered.
            </summary>
            <returns>
            the scheduler's <see cref="T:Quartz.IListenerManager"/>
            </returns>
            <seealso cref="P:Quartz.IScheduler.ListenerManager"/><seealso cref="T:Quartz.IJobListener"/><seealso cref="T:Quartz.ITriggerListener"/><seealso cref="T:Quartz.ISchedulerListener"/>
        </member>
        <member name="P:Castle.Facilities.QuartzIntegration.QuartzNetScheduler.IsStarted">
            <summary>
            Whether the scheduler has been started.  
            </summary>
            <remarks>
            Note: This only reflects whether <see cref="M:Quartz.IScheduler.Start"/> has ever
                        been called on this Scheduler, so it will return <see langword="true"/> even 
                        if the <see cref="T:Quartz.IScheduler"/> is currently in standby mode or has been 
                        since shutdown.
            </remarks>
            <seealso cref="M:Quartz.IScheduler.Start"/><seealso cref="P:Quartz.IScheduler.IsShutdown"/><seealso cref="P:Quartz.IScheduler.InStandbyMode"/>
        </member>
        <member name="T:Castle.Facilities.QuartzIntegration.QuartzNetSimpleScheduler">
            <summary>
            Light-weight job scheduler
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetSimpleScheduler.#ctor(Quartz.IScheduler)">
            <summary>
            
            </summary>
            <param name="scheduler"></param>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetSimpleScheduler.ResumeJob(Quartz.JobKey)">
            <summary>
            Resumes triggers of a paused job
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetSimpleScheduler.Interrupt(Quartz.JobKey)">
            <summary>
            Interrupts a running job
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetSimpleScheduler.GetJobStatus(Quartz.JobKey)">
            <summary>
            Gets the job status, assuming it has only one trigger
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetSimpleScheduler.RunJob(Quartz.JobKey)">
            <summary>
            Runs a job immediately
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetSimpleScheduler.PauseAll">
            <summary>
            Pauses all triggers
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetSimpleScheduler.ResumeAll">
            <summary>
            Resumes all triggers
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.QuartzNetSimpleScheduler.PauseJob(Quartz.JobKey)">
            <summary>
            Pauses a job's triggers
            </summary>
        </member>
        <member name="T:Castle.Facilities.QuartzIntegration.ReleasingJobListener">
            <summary>
            JobListener that will release Jobs out of the Kernel
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.ReleasingJobListener.#ctor(Castle.MicroKernel.IKernel)">
            <summary>
            JobListener that will release Jobs out of the Kernel
            </summary>
            <param name="kernel">Windsor Kernel</param>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.ReleasingJobListener.JobExecutionVetoed(Quartz.IJobExecutionContext)">
            <summary>
            Called by the <see cref="T:Quartz.IScheduler"/> when a <see cref="T:Quartz.IJobDetail"/>
                        was about to be executed (an associated <see cref="T:Quartz.ITrigger"/>
                        has occurred), but a <see cref="T:Quartz.ITriggerListener"/> vetoed it's 
                        execution.
            </summary>
            <seealso cref="M:Quartz.IJobListener.JobToBeExecuted(Quartz.IJobExecutionContext)"/>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.ReleasingJobListener.JobToBeExecuted(Quartz.IJobExecutionContext)">
            <summary>
            Called by the <see cref="T:Quartz.IScheduler"/> when a <see cref="T:Quartz.IJobDetail"/>
                        is about to be executed (an associated <see cref="T:Quartz.ITrigger"/>
                        has occurred).
            <para>
            This method will not be invoked if the execution of the Job was vetoed
                        by a <see cref="T:Quartz.ITriggerListener"/>.
            </para>
            </summary>
            <seealso cref="M:Quartz.IJobListener.JobExecutionVetoed(Quartz.IJobExecutionContext)"/>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.ReleasingJobListener.JobWasExecuted(Quartz.IJobExecutionContext,Quartz.JobExecutionException)">
            <summary>
            Called by the <see cref="T:Quartz.IScheduler"/> after a <see cref="T:Quartz.IJobDetail"/>
                        has been executed, and be for the associated <see cref="T:Quartz.Spi.IOperableTrigger"/>'s
                        <see cref="M:Quartz.Spi.IOperableTrigger.Triggered(Quartz.ICalendar)"/> method has been called.
            </summary>
        </member>
        <member name="P:Castle.Facilities.QuartzIntegration.ReleasingJobListener.Name">
            <summary>
            Get the name of the <see cref="T:Quartz.IJobListener"/>.
            </summary>
        </member>
        <member name="T:Castle.Facilities.QuartzIntegration.WindsorJobFactory">
            <summary>
            Creates a Quartz job with Windsor
            </summary>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.WindsorJobFactory.#ctor(Castle.MicroKernel.IKernel)">
            <summary>
            Creates a Quartz job with Windsor
            </summary>
            <param name="kernel">Windsor Kernel</param>
        </member>
        <member name="M:Castle.Facilities.QuartzIntegration.WindsorJobFactory.NewJob(Quartz.Spi.TriggerFiredBundle,Quartz.IScheduler)">
            <summary>
            Called by the scheduler at the time of the trigger firing, in order to
                        produce a <see cref="T:Quartz.IJob"/> instance on which to call Execute.
            </summary>
            <remarks>
            It should be extremely rare for this method to throw an exception -
                        basically only the the case where there is no way at all to instantiate
                        and prepare the Job for execution.  When the exception is thrown, the
                        Scheduler will move all triggers associated with the Job into the
                        <see cref="F:Quartz.TriggerState.Error"/> state, which will require human
                        intervention (e.g. an application restart after fixing whatever 
                        configuration problem led to the issue wih instantiating the Job. 
            </remarks>
            <param name="bundle">The TriggerFiredBundle from which the <see cref="T:Quartz.IJobDetail"/>
                          and other info relating to the trigger firing can be obtained.
                        </param><param name="scheduler">a handle to the scheduler that is about to execute the job</param><throws>SchedulerException if there is a problem instantiating the Job. </throws>
            <returns>
            the newly instantiated Job
            </returns>
        </member>
        <member name="P:Castle.Facilities.QuartzIntegration.WindsorJobFactory.ResolveByJobName">
            <summary>
            Resolve a Job by it's name
            </summary>
        </member>
    </members>
</doc>
